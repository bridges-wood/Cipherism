package cipher;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Hashtable;
import java.util.TreeMap;
import java.util.stream.Collectors;

public class DetectEnglish {

	private Hashtable<Long, String> dictionaryTable, mostLikelyTable, twoGramsTable;
	private TreeMap<String, Double> firstOrder, secondOrder;
	private TreeMap<Character, Double> letterProbabilities;
	private double[] unseenScores;
	private Utilities u;
	private NGramAnalyser n;

	DetectEnglish() {
		dictionaryTable = new Hashtable<Long, String>();
		mostLikelyTable = new Hashtable<Long, String>();
		twoGramsTable = new Hashtable<Long, String>();
		firstOrder = new TreeMap<String, Double>();
		secondOrder = new TreeMap<String, Double>();
		letterProbabilities = new TreeMap<Character, Double>();
		unseenScores = new double[50];
		u = new Utilities();
		n = new NGramAnalyser();
	}

	/**
	 * Returns what fraction of the text can be called English.
	 * 
	 * @param text The text to be analysed.
	 * @return Float representing the fraction of text that can be classified as
	 *         English. Scores above 0.75 for unspaced text and 0.85 for spaced text
	 *         are good indications of English.
	 */
	public float detectEnglish(String text) {
		text = text.toLowerCase();
		boolean spaced = false;
		for (int i = 0; i < text.length(); i++) {
			if (text.charAt(i) == ' ') {
				spaced = true;
				break;
			}
		}
		if (spaced) {
			ArrayList<String> words = new ArrayList<String>(Arrays.asList(text.replaceAll(
					"[!\\\"\\£\\$\\%\\^\\&\\*\\(\\)\\_\\'\\+\\=\\{\\}\\[\\]\\;\\:\\@\\#\\~\\|\\<\\,\\.\\>\\/]", "")
					.split(" "))); // Removal of all unwanted characters, leaving only hyphens and alphabetical
									// characters and conversion to list..
			ArrayList<String> toRemove = new ArrayList<String>();
			for (String word : words) {
				char[] letters = word.toCharArray();
				for (int i = 0; i < word.length(); i++) {
					if (letters[i] == '-') {
						toRemove.add(word); // If a word contains a '-' it needs to cleaned up because the dictionary
											// does not deal well with compounded words.
					}
				}
			}
			for (String word : toRemove) { // For all the hyphenated words...
				words.remove(word);
				String[] split = word.split("-");
				for (String part : split) { // Split them by the hyphen and add the separate parts back in.
					words.add(part);
				}
			}
			return isEnglish(words.toArray(new String[0]));

		} else {
			return isEnglish(respace(text, 20).split(" "));
		}
	}

	/**
	 * Returns the fraction of words that are English in a given array.
	 * 
	 * @param words An array of words to be analysed for English text.
	 * @return Float representing the fraction of words in the array that are
	 *         English.
	 */
	@SuppressWarnings("unchecked")
	public float isEnglish(String[] words) {
		if (dictionaryTable.isEmpty()) {
			dictionaryTable = (Hashtable<Long, String>) u.readHashTable("dictionary.htb");
		}
		float englishWords = 0f;
		for (String word : words) {
			long hashedWord = u.hash64(word);
			if (dictionaryTable.containsKey(hashedWord)) {
				englishWords += 1;
			}
		}
		return englishWords / words.length;
	}

	/**
	 * Find the first match with the text using the most likely groups of words.
	 * 
	 * @param possibleGroups A list of all the possible groups of words that could
	 *                       be in the text.
	 * @param letters
	 * @return An integer array of length 2, [0] being the length of the first word
	 *         to add and [1] being the position of the space.
	 */
	public int[] firstMatch(ArrayList<String> possibleGroups, ArrayList<Character> letters) {
		for (String pair : possibleGroups) {
			char[] characters = pair.replaceAll(" ", "").toCharArray();
			boolean match = true;
			for (int i = 0; i < characters.length && i < letters.size(); i++) {
				if (characters[i] != letters.get(i)) {
					match = false;
					break;
				}
			}
			if (match) {
				int a = pair.length() - 1;
				int b = pair.indexOf(" ");
				return new int[] { a, b };
			}
		}
		return new int[2];
	}

	/**
	 * Ranks all of the possible word pairs generated by the analysis of the text.
	 * 
	 * @param pair           The GroupProbabilityPair object to be inserted into the
	 *                       list into probability order.
	 * @param possibleGroups The list of currently sorted probability groups.
	 * @return The updated list of possible word groups.
	 */
	public ArrayList<GroupProbabilityPair> rank(GroupProbabilityPair pair,
			ArrayList<GroupProbabilityPair> possibleGroups) {
		for (int i = 0; i < possibleGroups.size(); i++) { // Iterates through the list of possible word groups...
			if (pair.getRank() < possibleGroups.get(i).getRank()) {// When the the chance of getting the group being
																	// compared is higher than that in the position in
																	// the list...
				possibleGroups.add(i, pair); // Insert the group into that position.
				return possibleGroups;
			}
		}
		possibleGroups.add(pair); // If it's not more likely than any other existing group, add it to the end of
									// the list.
		return possibleGroups;
	}

	/**
	 * Finds the English words present in the first characters of a string.
	 * 
	 * @param letters An ArrayList of all letters in a given text.
	 * @return An array containing of size 2 with all words found at [0] and
	 *         probable words stored at [1].
	 */
	@SuppressWarnings("unchecked")
	public ArrayList<String>[] findWords(ArrayList<Character> letters) {
		if (dictionaryTable.isEmpty()) {
			dictionaryTable = (Hashtable<Long, String>) u.readHashTable("dictionary.htb");
		}
		if (mostLikelyTable.isEmpty()) {
			mostLikelyTable = (Hashtable<Long, String>) u.readHashTable("mostProbable.htb");
		}
		ArrayList<String> foundWords = new ArrayList<String>();
		ArrayList<String> probableWords = new ArrayList<String>();
		StringBuilder word = new StringBuilder();
		int firstLength = 0;
		for (int i = 0; i < letters.size(); i++) { // Detecting the first word.
			word.append(letters.get(i));
			if (dictionaryTable.containsKey(u.hash64(word.toString()))) {
				foundWords.add(word.toString()); // If the group of characters has a corresponding hash in the
													// dictionary, we've found a word.
				if (mostLikelyTable.containsKey(u.hash64(word.toString()))) {
					probableWords.add(word.toString()); // If it also has a hash in the most likely words hashtable,
														// we've found a likely word.
				}
				firstLength = i; // This allows us to speed up our looking for words, as we can ignore letters
									// before this number, and we can avoid looking at words that are too long.
				break;
			}
		}
		for (int i = firstLength + 1; i < 20 && i < letters.size(); i++) { // Avoid ArrayIndexOutOfBoundsErrors and
																			// ignore
																			// words that are longer than the longest
																			// common word in
																			// English.
			word.append(letters.get(i));
			if (dictionaryTable.containsKey(u.hash64(word.toString()))) {
				foundWords.add(word.toString());
				if (mostLikelyTable.containsKey(u.hash64(word.toString()))) {
					probableWords.add(word.toString());
				}
			}
		}
		if (foundWords.size() > 0 && !probableWords.contains(foundWords.get(foundWords.size() - 1))) {
			// This introduces the longest found word into probable words, even if it isn't
			// particularly likely on its own. This is to try and mitigate over-prediction
			// of short words.
			probableWords.add(foundWords.get(foundWords.size() - 1));
		}
		ArrayList<String>[] out = new ArrayList[2];
		out[0] = foundWords;
		out[1] = probableWords;
		return out;
	}

	/**
	 * @deprecated Due to HUGE inefficiencies, this has been replaced by
	 *             {@link #respace(String, int)} .
	 */
	@SuppressWarnings("unchecked")
	public String respace(String text) {
		if (twoGramsTable.isEmpty()) {
			twoGramsTable = (Hashtable<Long, String>) u.readHashTable("2grams.htb");
		}
		ArrayList<Character> letters = (ArrayList<Character>) text.toLowerCase().replaceAll("[^a-zA-Z ]", "").chars()
				.mapToObj(e -> (char) e).collect(Collectors.toList());
		StringBuilder out = new StringBuilder();
		boolean changes = false;
		while (letters.size() > 0) {
			ArrayList<String>[] words = findWords(letters);
			ArrayList<String> foundWords = words[0];
			ArrayList<String> probableWords = words[1];
			ArrayList<String> possibleGroups = new ArrayList<String>();
			for (String word : probableWords) {
				StringBuilder succeeding = new StringBuilder();
				int length = word.length();
				switch (length) { // More cases can be added if I find more refined patterns in word lengths.
				case 1:
					for (int i = 0; i < 2 && i + length < letters.size(); i++) {
						succeeding.append(letters.get(length + i));
					}
					break;
				default:
					if (length < letters.size()) {
						succeeding.append(letters.get(length));
					}
					break;
				}
				String toCheck = word + "," + succeeding.toString();
				String[] lines = u.readFile("2grams.txt"); // Goes through all likely two word combinations and
				for (String line : lines) {
					if (line.startsWith(toCheck)) {
						possibleGroups.add(line.replaceAll(",", " "));
						break;
					}
				}

			}
			int[] toRemove = firstMatch(possibleGroups, letters); // Check if this equals 0, then examine words in
																	// foundWords.
			if (toRemove[0] > 0) {
				if (changes == false && out.length() > 0)
					out.append(" ");
				for (int i = 0; i < toRemove[0] && letters.size() > 0; i++) {
					out.append(letters.get(0));
					if (i == toRemove[1] - 1) {
						out.append(" ");
					}
					letters.remove(0);
				}
				out.append(" ");
				changes = true;
			} else {
				// Examine found words and select the most likely.
				String wordToRemove = "";
				boolean found = false;
				for (String word : foundWords) {
					if (mostLikelyTable.containsKey(u.hash64(word))) {
						wordToRemove = word;
						found = true;
						break;
					}
					if (found)
						break;
				}
				if (wordToRemove == "") {
					out.append(letters.get(0));
					letters.remove(0);
					changes = false;
				} else {
					for (int i = 0; i < wordToRemove.length(); i++) {
						out.append(letters.get(0));
						letters.remove(0);
					}
					out.append(" ");
					changes = true;
				}
			}
		}
		return out.toString();
	}

	/**
	 * Determines the probability of a word or group of words.
	 * 
	 * @param word The word to be examined.
	 * @param prev The previous word. Null if only one word wants to be examined.
	 * @return The probability of getting that word in Google's trillion word
	 *         corpus.
	 */
	public double conditionalWordProbability(String word, String prev) {
		if (prev == null)
			prev = "<UNK>";
		if (!firstOrder.containsKey(word)) { // If this word hasn't been seen on its own...
			return unseenScores[word.length()];
		} else if (!secondOrder.containsKey(prev + " " + word)) { // If the word hasn't been seen with the previous...
			return firstOrder.get(word);
		} else { // If the word has been seen with the previous...
			return secondOrder.get(prev + " " + word);
		}
	}

	/**
	 * Takes in text and determines using logarithmic word probabilities from
	 * Google's Trillion Word Corpus, the most likely respaced version of the text.
	 * 
	 * @param text          The text to be respaced into English.
	 * @param maxWordLength The length of the longest word that could be found in
	 *                      the text.
	 * @return The respaced text.
	 */
	@SuppressWarnings("unchecked")
	public String respace(String text, int maxWordLength) {
		if (dictionaryTable.isEmpty()) {
			dictionaryTable = (Hashtable<Long, String>) u.readHashTable("dictionary.htb");
		} // Loads the dictionary hashtable.
		String[] lines = u.readFile("1w.txt");
		double N = 1024908267229d; // The total number of words in the corpus.
		for (String line : lines) {
			String[] splitLine = line.split(",");
			double valueToInsert = Math.log10(Double.valueOf(splitLine[1]) / N);
			firstOrder.put(splitLine[0], valueToInsert); // For all words on their own, their logarithmic probability is
															// added to a map.
		}
		lines = u.readFile("2w.txt");
		for (String line : lines) {
			String[] splitLine = line.split(",");
			double valueToInsert;
			if (!firstOrder.containsKey(splitLine[0])) { // If we haven't seen the first word in the group before...
				valueToInsert = Math.log10(Double.parseDouble(splitLine[2]) / N);
				// We add the probability of the group to the map.
			} else { // If we have seen the first word before...
				// We add the probability of the pair of words to the the map.
				valueToInsert = Math.log10(Double.parseDouble(splitLine[2]) / N) - firstOrder.get(splitLine[0]);
			}
			secondOrder.put(splitLine[0] + " " + splitLine[1], valueToInsert);
		}
		for (int i = 0; i < 50; i++) { // Precalculate the probabilities of unseen words.
			unseenScores[i] = Math.log10(10d / (N * Math.pow(10, i)));
		}
		ArrayList<Character> letters = (ArrayList<Character>) u.cleanText(text).chars().mapToObj(e -> (char) e)
				.collect(Collectors.toList()); // Clean up text and stream to list.
		StringBuilder out = new StringBuilder();
		boolean failed = false;
		while (letters.size() > 0) {
			TreeMap<Double, String> firstWords = new TreeMap<Double, String>();
			StringBuilder word = new StringBuilder();
			for (int i = 0; i < maxWordLength; i++) {
				if (i > letters.size() - 1)
					break;
				word.append(letters.get(i));
				firstWords.put(conditionalWordProbability(word.toString(), null), word.toString());
			} // Creates a map of all the words at the start of the string in order of their
				// probability.
			TreeMap<Double, String> compositeScores = new TreeMap<Double, String>();
			for (Double probability : firstWords.descendingKeySet()) { // Examines words in probability order. (The
																		// order doesn't strictly matter here, but it
																		// more quickly finds the last word at the end)
				String possWord = firstWords.get(probability);
				if (!dictionaryTable.containsKey(u.hash64(possWord)) && !failed) { // If the word is not
																					// English, it is skipped.
					continue;
				}
				if (failed || dictionaryTable.containsKey(u.hash64(possWord))) {
					if (possWord.length() == letters.size()) { // If the word finishes the phrase, it is automatically
																// set as the only possible word.
						compositeScores.clear();
						compositeScores.put(0d, possWord);
						break;
					}
					int adjustment = possWord.length(); // Allows us to examine just words after the word we're looking
														// for succeeding words for.
					word = new StringBuilder();
					double compositeScore = -50000; // This is sufficiently low to allow almost all scores to beat it.
					for (int i = adjustment; i < maxWordLength + adjustment; i++) { // For every word up to the maximum
																					// length after out first...
						if (i > letters.size() - 1)
							break; // Prevents index out of range.
						word.append(letters.get(i));
						double tempScore = -50000;
						if (dictionaryTable.containsKey(u.hash64(word.toString()))) {
							tempScore = conditionalWordProbability(word.toString(), possWord)
									+ word.toString().length();
							// Add the length to the score as a modifier to favour the longer words.
						}
						if (tempScore > compositeScore) {
							compositeScore = tempScore; // If the score is higher than the first word's current max, it
														// is replaced.
						}
					}
					compositeScores.put(compositeScore, possWord); // Each word composite score pair is added to a map.
				}
			}
			if (compositeScores.size() > 0) {
				String toRemove = compositeScores.get(compositeScores.lastKey()); // The most likely word is then chosen
																					// and removed and the process
																					// starts again.
				out.append(toRemove + " ");
				if (letters.size() > 0) {
					for (int i = 0; i < toRemove.length(); i++) {
						letters.remove(0);
					}
				}
			} else {
				failed = true; // This is to allow respacing of non-recognizable strings. If it fails, one word
								// must automatically be removed instead of an infinite loop where none are
								// removed.
			}
		}
		return out.toString().trim();
	}

	/**
	 * Gives the score of the given text as how close the text is to English.
	 * 
	 * @param text The text to be analysed.
	 * @return The Chi Squared value.
	 */
	public double chiSquaredTest(String text) {
		if (letterProbabilities.isEmpty()) {
			String[] lines = u.readFile("1l.txt"); // 4374127904 is total to divide by.
			for (String line : lines) {
				String[] splitLine = line.split(",");
				letterProbabilities.put(splitLine[0].charAt(0), Double.parseDouble(splitLine[1]) / 4374127904d);
				// Puts the probability of the specified letter into the map.
			}
		}
		text = u.cleanText(text);
		double length = text.length();
		double score = 0;
		TreeMap<String, Integer> letterFrequencies = n.frequencyAnalysis(text);
		for (Character letter : letterProbabilities.keySet()) {
			double expectedCount = letterProbabilities.get(letter) * length;
			score += Math.pow(letterFrequencies.get(letter.toString()) - expectedCount, 2) / expectedCount;
		}
		return score;
	}

}
